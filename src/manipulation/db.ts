import Database from 'better-sqlite3';
import path from 'path';
import { fileURLToPath } from 'url';
import type { StoredTrade, WalletProfile, MarketMeta, ManipulationAlert } from './types.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const DB_PATH = path.join(__dirname, '../../data/manipulation.db');

const db = new Database(DB_PATH);

// Initialize tables for manipulation detection
db.exec(`
  -- Raw trades from RTDS stream
  CREATE TABLE IF NOT EXISTS trades (
    id TEXT PRIMARY KEY,
    timestamp INTEGER NOT NULL,
    market_id TEXT NOT NULL,
    wallet TEXT NOT NULL,
    side TEXT NOT NULL,
    outcome TEXT NOT NULL,
    size REAL NOT NULL,
    price REAL NOT NULL
  );

  -- Wallet profiles (computed periodically)
  CREATE TABLE IF NOT EXISTS wallet_profiles (
    address TEXT PRIMARY KEY,
    first_seen INTEGER NOT NULL,
    last_seen INTEGER NOT NULL,
    trade_count INTEGER NOT NULL,
    unique_markets INTEGER NOT NULL,
    total_volume REAL NOT NULL,
    avg_trade_size REAL NOT NULL,
    win_rate REAL,
    resolved_positions INTEGER
  );

  -- Market metadata cache
  CREATE TABLE IF NOT EXISTS market_meta (
    id TEXT PRIMARY KEY,
    question TEXT NOT NULL,
    category TEXT NOT NULL,
    end_date TEXT NOT NULL,
    fetched_at INTEGER NOT NULL
  );

  -- Signature tallies for pattern detection
  CREATE TABLE IF NOT EXISTS signature_tallies (
    signature_hash TEXT PRIMARY KEY,
    count INTEGER DEFAULT 1,
    wallets TEXT NOT NULL,
    markets TEXT NOT NULL,
    first_seen INTEGER NOT NULL,
    last_seen INTEGER NOT NULL,
    alert_triggered INTEGER DEFAULT 0
  );

  -- Alerts generated by detection
  CREATE TABLE IF NOT EXISTS alerts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,
    severity TEXT NOT NULL,
    signature_hash TEXT,
    wallets TEXT NOT NULL,
    markets TEXT NOT NULL,
    details TEXT NOT NULL,
    created_at INTEGER NOT NULL,
    reviewed INTEGER DEFAULT 0
  );

  -- Indexes for fast queries
  CREATE INDEX IF NOT EXISTS idx_trades_timestamp ON trades(timestamp);
  CREATE INDEX IF NOT EXISTS idx_trades_wallet ON trades(wallet);
  CREATE INDEX IF NOT EXISTS idx_trades_market ON trades(market_id);
  CREATE INDEX IF NOT EXISTS idx_wallet_volume ON wallet_profiles(total_volume DESC);
`);

// ============ Trade Operations ============

export function saveTrade(trade: StoredTrade): void {
  const stmt = db.prepare(`
    INSERT OR IGNORE INTO trades (id, timestamp, market_id, wallet, side, outcome, size, price)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);
  stmt.run(trade.id, trade.timestamp, trade.marketId, trade.wallet, trade.side, trade.outcome, trade.size, trade.price);
}

export function saveTrades(trades: StoredTrade[]): number {
  const stmt = db.prepare(`
    INSERT OR IGNORE INTO trades (id, timestamp, market_id, wallet, side, outcome, size, price)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const insertMany = db.transaction((trades: StoredTrade[]) => {
    let inserted = 0;
    for (const t of trades) {
      const result = stmt.run(t.id, t.timestamp, t.marketId, t.wallet, t.side, t.outcome, t.size, t.price);
      if (result.changes > 0) inserted++;
    }
    return inserted;
  });

  return insertMany(trades);
}

export function getTradeCount(): number {
  const row = db.prepare('SELECT COUNT(*) as count FROM trades').get() as { count: number };
  return row.count;
}

export function getTradesForWallet(wallet: string, limit = 100): StoredTrade[] {
  const rows = db.prepare(`
    SELECT * FROM trades WHERE wallet = ? ORDER BY timestamp DESC LIMIT ?
  `).all(wallet, limit) as any[];

  return rows.map(r => ({
    id: r.id,
    timestamp: r.timestamp,
    marketId: r.market_id,
    wallet: r.wallet,
    side: r.side,
    outcome: r.outcome,
    size: r.size,
    price: r.price,
  }));
}

export function getTradesForMarket(marketId: string, limit = 1000): StoredTrade[] {
  const rows = db.prepare(`
    SELECT * FROM trades WHERE market_id = ? ORDER BY timestamp DESC LIMIT ?
  `).all(marketId, limit) as any[];

  return rows.map(r => ({
    id: r.id,
    timestamp: r.timestamp,
    marketId: r.market_id,
    wallet: r.wallet,
    side: r.side,
    outcome: r.outcome,
    size: r.size,
    price: r.price,
  }));
}

export function getRecentTrades(limit = 100): StoredTrade[] {
  const rows = db.prepare(`
    SELECT * FROM trades ORDER BY timestamp DESC LIMIT ?
  `).all(limit) as any[];

  return rows.map(r => ({
    id: r.id,
    timestamp: r.timestamp,
    marketId: r.market_id,
    wallet: r.wallet,
    side: r.side,
    outcome: r.outcome,
    size: r.size,
    price: r.price,
  }));
}

// ============ Wallet Profile Operations ============

export function updateWalletProfile(profile: WalletProfile): void {
  const stmt = db.prepare(`
    INSERT INTO wallet_profiles (address, first_seen, last_seen, trade_count, unique_markets, total_volume, avg_trade_size, win_rate, resolved_positions)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(address) DO UPDATE SET
      last_seen = excluded.last_seen,
      trade_count = excluded.trade_count,
      unique_markets = excluded.unique_markets,
      total_volume = excluded.total_volume,
      avg_trade_size = excluded.avg_trade_size,
      win_rate = excluded.win_rate,
      resolved_positions = excluded.resolved_positions
  `);

  stmt.run(
    profile.address,
    profile.firstSeen,
    profile.lastSeen,
    profile.tradeCount,
    profile.uniqueMarkets,
    profile.totalVolume,
    profile.avgTradeSize,
    profile.winRate ?? null,
    profile.resolvedPositions ?? null
  );
}

export function getWalletProfile(address: string): WalletProfile | null {
  const row = db.prepare('SELECT * FROM wallet_profiles WHERE address = ?').get(address) as any;
  if (!row) return null;

  return {
    address: row.address,
    firstSeen: row.first_seen,
    lastSeen: row.last_seen,
    tradeCount: row.trade_count,
    uniqueMarkets: row.unique_markets,
    totalVolume: row.total_volume,
    avgTradeSize: row.avg_trade_size,
    winRate: row.win_rate,
    resolvedPositions: row.resolved_positions,
  };
}

export function getTopWalletsByVolume(limit = 50): WalletProfile[] {
  const rows = db.prepare(`
    SELECT * FROM wallet_profiles ORDER BY total_volume DESC LIMIT ?
  `).all(limit) as any[];

  return rows.map(r => ({
    address: r.address,
    firstSeen: r.first_seen,
    lastSeen: r.last_seen,
    tradeCount: r.trade_count,
    uniqueMarkets: r.unique_markets,
    totalVolume: r.total_volume,
    avgTradeSize: r.avg_trade_size,
    winRate: r.win_rate,
    resolvedPositions: r.resolved_positions,
  }));
}

// ============ Market Meta Operations ============

export function saveMarketMeta(meta: MarketMeta): void {
  const stmt = db.prepare(`
    INSERT OR REPLACE INTO market_meta (id, question, category, end_date, fetched_at)
    VALUES (?, ?, ?, ?, ?)
  `);
  stmt.run(meta.id, meta.question, meta.category, meta.endDate, meta.fetchedAt);
}

export function getMarketMeta(id: string): MarketMeta | null {
  const row = db.prepare('SELECT * FROM market_meta WHERE id = ?').get(id) as any;
  if (!row) return null;

  return {
    id: row.id,
    question: row.question,
    category: row.category,
    endDate: row.end_date,
    fetchedAt: row.fetched_at,
  };
}

// ============ Alert Operations ============

export function saveAlert(alert: ManipulationAlert): number {
  const stmt = db.prepare(`
    INSERT INTO alerts (type, severity, signature_hash, wallets, markets, details, created_at, reviewed)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);

  const result = stmt.run(
    alert.type,
    alert.severity,
    alert.signatureHash ?? null,
    JSON.stringify(alert.wallets),
    JSON.stringify(alert.markets),
    alert.details,
    alert.createdAt,
    alert.reviewed ? 1 : 0
  );

  return result.lastInsertRowid as number;
}

export function getRecentAlerts(limit = 50): ManipulationAlert[] {
  const rows = db.prepare(`
    SELECT * FROM alerts ORDER BY created_at DESC LIMIT ?
  `).all(limit) as any[];

  return rows.map(r => ({
    id: r.id,
    type: r.type,
    severity: r.severity,
    signatureHash: r.signature_hash,
    wallets: JSON.parse(r.wallets),
    markets: JSON.parse(r.markets),
    details: r.details,
    createdAt: r.created_at,
    reviewed: r.reviewed === 1,
  }));
}

// ============ Stats ============

export function getStats(): { trades: number; wallets: number; markets: number; alerts: number } {
  const trades = (db.prepare('SELECT COUNT(*) as c FROM trades').get() as any).c;
  const wallets = (db.prepare('SELECT COUNT(DISTINCT wallet) as c FROM trades').get() as any).c;
  const markets = (db.prepare('SELECT COUNT(DISTINCT market_id) as c FROM trades').get() as any).c;
  const alerts = (db.prepare('SELECT COUNT(*) as c FROM alerts').get() as any).c;

  return { trades, wallets, markets, alerts };
}

export { db };
